import { expect } from "chai";
import { ethers } from "hardhat";
import { Coffee } from "../typechain-types"; // This is generated by Hardhat
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";

describe("Coffee Contract", function () {
  let coffee: Coffee;
  let owner: SignerWithAddress;
  let tipper: SignerWithAddress;
  let stranger: SignerWithAddress;

  // 1. SETUP: Runs before every test
  beforeEach(async function () {
    [owner, tipper, stranger] = await ethers.getSigners();
    const CoffeeFactory = await ethers.getContractFactory("Coffee");
    coffee = await CoffeeFactory.deploy(); // Deploys to local Hardhat network
  });

  // 2. TEST: Buying Coffee
  it("Should allow a user to buy a coffee and update state", async function () {
    const tipAmount = ethers.parseEther("0.1");
    
    // Call buyCoffee from the 'tipper' account
    await coffee.connect(tipper).buyCoffee("Alice", "Great project!", { value: tipAmount });

    // Check if memoCount increased
    expect(await coffee.memoCount()).to.equal(1);

    // Check if the memo data is correct
    const memos = await coffee.getMemos();
    expect(memos[0].name).to.equal("Alice");
    expect(memos[0].from).to.equal(tipper.address);
  });

  // 3. TEST: Events
  it("Should emit a newMemo event when coffee is bought", async function () {
    const tipAmount = ethers.parseEther("0.1");

    await expect(coffee.connect(tipper).buyCoffee("Bob", "Thanks!", { value: tipAmount }))
    .to.emit(coffee, "newMemo")
    .withArgs(1, tipper.address, anyValue, "Bob", "Thanks!"); 
    // anyValue helps if you don't want to calculate the exact timestamp
  });

  // 4. TEST: Withdrawals & Security
  it("Should allow the owner to withdraw tips", async function () {
    // Buy a coffee first
    await coffee.connect(tipper).buyCoffee("Alice", "Tip", { value: ethers.parseEther("1.0") });

    // Withdraw and check if balance changes
    const initialOwnerBalance = await ethers.provider.getBalance(owner.address);
    await coffee.connect(owner).withdrawTip();
    const finalOwnerBalance = await ethers.provider.getBalance(owner.address);

    expect(finalOwnerBalance).to.be.gt(initialOwnerBalance);
  });

  it("Should REVERT if a non-owner tries to withdraw", async function () {
    await expect(coffee.connect(stranger).withdrawTip())
      .to.be.revertedWithCustomError(coffee, "OwnableUnauthorizedAccount"); 
      // This is a standard OpenZeppelin error
  });
});